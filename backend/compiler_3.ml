open Common
open Common.Interp_3
open Frontend
(* COMPILE *)


let new_label =
  let i = ref 0 in
  let get () =
    let v = !i in
    i := !i + 1 ;
    "L" ^ string_of_int v
  in
  get

let rec comp = function
  | Ast.Unit -> ([], [PUSH UNIT])
  | Integer n -> ([], [PUSH (INT n)])
  | Boolean b -> ([], [PUSH (BOOL b)])
  | Var x -> ([], [LOOKUP x])
  | UnaryOp (op, e) ->
      let defs, c = comp e in
      (defs, c @ [UNARY op])
  | Op (e1, op, e2) ->
      let defs1, c1 = comp e1 in
      let defs2, c2 = comp e2 in
      (defs1 @ defs2, c1 @ c2 @ [OPER op])
  | Pair (e1, e2) ->
      let defs1, c1 = comp e1 in
      let defs2, c2 = comp e2 in
      (defs1 @ defs2, c1 @ c2 @ [MK_PAIR])
  | Fst e ->
      let defs, c = comp e in
      (defs, c @ [FST])
  | Snd e ->
      let defs, c = comp e in
      (defs, c @ [SND])
  | Inl e ->
      let defs, c = comp e in
      (defs, c @ [MK_INL])
  | Inr e ->
      let defs, c = comp e in
      (defs, c @ [MK_INR])
  | Case (e1, (x1, e2), (x2, e3)) ->
      let inr_label = new_label () in
      let after_inr_label = new_label () in
      let defs1, c1 = comp e1 in
      let defs2, c2 = comp e2 in
      let defs3, c3 = comp e3 in
      ( defs1 @ defs2 @ defs3
      , c1
        @ [CASE (inr_label, None)]
        @ ((BIND x1 :: c2) @ [SWAP; POP])
        @ [GOTO (after_inr_label, None); LABEL inr_label]
        @ ((BIND x2 :: c3) @ [SWAP; POP])
        @ [LABEL after_inr_label] )
  | If (e1, e2, e3) ->
      let else_label = new_label () in
      let after_else_label = new_label () in
      let defs1, c1 = comp e1 in
      let defs2, c2 = comp e2 in
      let defs3, c3 = comp e3 in
      ( defs1 @ defs2 @ defs3
      , c1
        @ [TEST (else_label, None)]
        @ c2
        @ [GOTO (after_else_label, None); LABEL else_label]
        @ c3 @ [LABEL after_else_label] )
  | Seq [] -> ([], [])
  | Seq [e] -> comp e
  | Seq (e :: rest) ->
      let defs1, c1 = comp e in
      let defs2, c2 = comp (Seq rest) in
      (defs1 @ defs2, c1 @ [POP] @ c2)
  | Ref e ->
      let defs, c = comp e in
      (defs, c @ [MK_REF])
  | Deref e ->
      let defs, c = comp e in
      (defs, c @ [DEREF])
  | While (e1, e2) ->
      let test_label = new_label () in
      let end_label = new_label () in
      let defs1, c1 = comp e1 in
      let defs2, c2 = comp e2 in
      ( defs1 @ defs2
      , [LABEL test_label] @ c1
        @ [TEST (end_label, None)]
        @ c2
        @ [POP; GOTO (test_label, None); LABEL end_label; PUSH UNIT] )
  | Assign (e1, e2) ->
      let defs1, c1 = comp e1 in
      let defs2, c2 = comp e2 in
      (defs1 @ defs2, c1 @ c2 @ [ASSIGN])
  | App (e1, e2) ->
      let defs1, c1 = comp e1 in
      let defs2, c2 = comp e2 in
      (defs1 @ defs2, c2 @ c1 @ [APPLY])
  | Lambda (x, e) ->
      let defs, c = comp e in
      let f = new_label () in
      let def = [LABEL f; BIND x] @ c @ [SWAP; POP; RETURN] in
      (def @ defs, [MK_CLOSURE (f, None)])
  (*
 Note that we could have

 | LetFun(f, (x, e1), e2) -> comp (App(Lambda(f, e2), Lambda(x, e1)))

 This would then result (ignoring the defs generated by subterms) in

    defs = [LABEL g ; BIND f] @ c2 @ [SWAP; POP; RETURN]
         @ [LABEL h; bind x ] @ c1 @ [SWAP; POP; RETURN]

    code = [MK_CLOSURE((h, None)); [MK_CLOSURE((g, None)); APPLY]

  where g and h are new labels.

  In contrast, the following version of comp results in

     defs = [LABEL f; BIND x] @ c1 @ [SWAP; POP; RETURN]

     code = [MK_CLOSURE((f, None)); BIND f] @ c2 @ [SWAP; POP])

  which is simpler.

*)
  | LetFun (f, (x, e1), e2) ->
      let defs1, c1 = comp e1 in
      let defs2, c2 = comp e2 in
      let def = [LABEL f; BIND x] @ c1 @ [SWAP; POP; RETURN] in
      (def @ defs1 @ defs2, [MK_CLOSURE (f, None); BIND f] @ c2 @ [SWAP; POP])
  | LetRecFun (f, (x, e1), e2) ->
      let defs1, c1 = comp e1 in
      let defs2, c2 = comp e2 in
      let def = [LABEL f; BIND x] @ c1 @ [SWAP; POP; RETURN] in
      (def @ defs1 @ defs2, [MK_CLOSURE (f, None); BIND f] @ c2 @ [SWAP; POP])

let compile (options: Options.t) e =
  let defs, c = comp e in
  let result =
    c (* body of program *)
    @ [HALT] (* stop the interpreter *)
    @ defs
  in
  if options.verbose_back then
    print_string ("\nCompiled Code = \n" ^ string_of_code result);

  result
